/*! osc.js 2.4.5, Copyright 2024 Colin Clark | github.com/colinbdclark/osc.js */
((i, o) => {
    "object" == typeof exports ? (i.osc = exports, o(0, require("slip"), require("EventEmitter"), require("long"))) : "function" == typeof define && define.amd ? define([ "exports", "slip", "EventEmitter", "long" ], function(e, t, r, n) {
        return i.osc = e, o(0, t, r, n);
    }) : (i.osc = {}, o(0, slip, EventEmitter));
})(this, function(e, n, t, r) {
    (d = d || {}).SECS_70YRS = 2208988800, d.TWO_32 = 4294967296, d.defaults = {
        metadata: !1,
        unpackSingleArgs: !0
    }, d.isCommonJS = !("undefined" == typeof module || !module.exports), d.isNode = d.isCommonJS && "undefined" == typeof window, 
    d.isElectron = !("undefined" == typeof process || !process.versions || !process.versions.electron), 
    d.isBufferEnv = d.isNode || d.isElectron, d.isArray = function(e) {
        return e && "[object Array]" === Object.prototype.toString.call(e);
    }, d.isTypedArrayView = function(e) {
        return e.buffer && e.buffer instanceof ArrayBuffer;
    }, d.isBuffer = function(e) {
        return d.isBufferEnv && e instanceof Buffer;
    }, d.Long = void 0 !== r ? r : d.isNode ? require("long") : void 0, d.TextDecoder = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : "undefined" != typeof util && (util.TextDecoder, 
    1) ? new util.TextDecoder("utf-8") : void 0, d.TextEncoder = "undefined" != typeof TextEncoder ? new TextEncoder("utf-8") : "undefined" != typeof util && (util.TextEncoder, 
    1) ? new util.TextEncoder("utf-8") : void 0, d.dataView = function(e, t, r) {
        return e.buffer ? new DataView(e.buffer, t, r) : e instanceof ArrayBuffer ? new DataView(e, t, r) : new DataView(new Uint8Array(e), t, r);
    }, d.byteArray = function(e) {
        if (e instanceof Uint8Array) return e;
        var t = e.buffer || e;
        if (t instanceof ArrayBuffer || void 0 !== t.length && "string" != typeof t) return new Uint8Array(t);
        throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " + JSON.stringify(e, null, 2));
    }, d.nativeBuffer = function(e) {
        return d.isBufferEnv ? d.isBuffer(e) ? e : Buffer.from(e.buffer ? e : new Uint8Array(e)) : d.isTypedArrayView(e) ? e : new Uint8Array(e);
    }, d.copyByteArray = function(e, t, r) {
        if (d.isTypedArrayView(e) && d.isTypedArrayView(t)) t.set(e, r); else for (var n = void 0 === r ? 0 : r, i = Math.min(t.length - r, e.length), o = 0, a = n; o < i; o++, 
        a++) t[a] = e[o];
        return t;
    }, d.readString = function(e, t) {
        for (var r = [], n = t.idx; n < e.byteLength; n++) {
            var i = e.getUint8(n);
            if (0 === i) {
                n++;
                break;
            }
            r.push(i);
        }
        return t.idx = n = n + 3 & -4, (d.isBufferEnv ? d.readString.withBuffer : d.TextDecoder ? d.readString.withTextDecoder : d.readString.raw)(r);
    }, d.readString.raw = function(e) {
        for (var t = "", r = 0; r < e.length; r += 1e4) t += String.fromCharCode.apply(null, e.slice(r, r + 1e4));
        return t;
    }, d.readString.withTextDecoder = function(e) {
        e = new Int8Array(e);
        return d.TextDecoder.decode(e);
    }, d.readString.withBuffer = function(e) {
        return Buffer.from(e).toString("utf-8");
    }, d.writeString = function(e) {
        for (var t, r = d.isBufferEnv ? d.writeString.withBuffer : d.TextEncoder ? d.writeString.withTextEncoder : null, n = e + "\0", i = (r && (t = r(n)), 
        (r ? t : n).length), o = new Uint8Array(i + 3 & -4), a = 0; a < i - 1; a++) {
            var s = r ? t[a] : n.charCodeAt(a);
            o[a] = s;
        }
        return o;
    }, d.writeString.withTextEncoder = function(e) {
        return d.TextEncoder.encode(e);
    }, d.writeString.withBuffer = function(e) {
        return Buffer.from(e);
    }, d.readPrimitive = function(e, t, r, n) {
        e = e[t](n.idx, !1);
        return n.idx += r, e;
    }, d.writePrimitive = function(e, t, r, n, i) {
        var o;
        return i = void 0 === i ? 0 : i, t ? o = new Uint8Array(t.buffer) : (o = new Uint8Array(n), 
        t = new DataView(o.buffer)), t[r](i, e, !1), o;
    }, d.readInt32 = function(e, t) {
        return d.readPrimitive(e, "getInt32", 4, t);
    }, d.writeInt32 = function(e, t, r) {
        return d.writePrimitive(e, t, "setInt32", 4, r);
    }, d.readInt64 = function(e, t) {
        var r = d.readPrimitive(e, "getInt32", 4, t), e = d.readPrimitive(e, "getInt32", 4, t);
        return d.Long ? new d.Long(e, r) : {
            high: r,
            low: e,
            unsigned: !1
        };
    }, d.writeInt64 = function(e, t, r) {
        var n = new Uint8Array(8);
        return n.set(d.writePrimitive(e.high, t, "setInt32", 4, r), 0), n.set(d.writePrimitive(e.low, t, "setInt32", 4, r + 4), 4), 
        n;
    }, d.readFloat32 = function(e, t) {
        return d.readPrimitive(e, "getFloat32", 4, t);
    }, d.writeFloat32 = function(e, t, r) {
        return d.writePrimitive(e, t, "setFloat32", 4, r);
    }, d.readFloat64 = function(e, t) {
        return d.readPrimitive(e, "getFloat64", 8, t);
    }, d.writeFloat64 = function(e, t, r) {
        return d.writePrimitive(e, t, "setFloat64", 8, r);
    }, d.readChar32 = function(e, t) {
        e = d.readPrimitive(e, "getUint32", 4, t);
        return String.fromCharCode(e);
    }, d.writeChar32 = function(e, t, r) {
        e = e.charCodeAt(0);
        if (!(void 0 === e || e < -1)) return d.writePrimitive(e, t, "setUint32", 4, r);
    }, d.readBlob = function(e, t) {
        var r = d.readInt32(e, t), n = r + 3 & -4, e = new Uint8Array(e.buffer, t.idx, r);
        return t.idx += n, e;
    }, d.writeBlob = function(e) {
        var t = (e = d.byteArray(e)).byteLength, r = new Uint8Array(4 + (t + 3 & -4)), n = new DataView(r.buffer);
        return d.writeInt32(t, n), r.set(e, 4), r;
    }, d.readMIDIBytes = function(e, t) {
        e = new Uint8Array(e.buffer, t.idx, 4);
        return t.idx += 4, e;
    }, d.writeMIDIBytes = function(e) {
        e = d.byteArray(e);
        var t = new Uint8Array(4);
        return t.set(e), t;
    }, d.readColor = function(e, t) {
        var e = new Uint8Array(e.buffer, t.idx, 4), r = e[3] / 255;
        return t.idx += 4, {
            r: e[0],
            g: e[1],
            b: e[2],
            a: r
        };
    }, d.writeColor = function(e) {
        var t = Math.round(255 * e.a);
        return new Uint8Array([ e.r, e.g, e.b, t ]);
    }, d.readTrue = function() {
        return !0;
    }, d.readFalse = function() {
        return !1;
    }, d.readNull = function() {
        return null;
    }, d.readImpulse = function() {
        return 1;
    }, d.readTimeTag = function(e, t) {
        var r = d.readPrimitive(e, "getUint32", 4, t), e = d.readPrimitive(e, "getUint32", 4, t);
        return {
            raw: [ r, e ],
            native: 0 === r && 1 === e ? Date.now() : d.ntpToJSTime(r, e)
        };
    }, d.writeTimeTag = function(e) {
        var e = e.raw || d.jsToNTPTime(e.native), t = new Uint8Array(8), r = new DataView(t.buffer);
        return d.writeInt32(e[0], r, 0), d.writeInt32(e[1], r, 4), t;
    }, d.timeTag = function(e, t) {
        e = e || 0;
        var t = (t = t || Date.now()) / 1e3, r = Math.floor(t), t = t - r, n = Math.floor(e), t = t + (e - n);
        return 1 < t && (n += e = Math.floor(t), t = t - e), {
            raw: [ r + n + d.SECS_70YRS, Math.round(d.TWO_32 * t) ]
        };
    }, d.ntpToJSTime = function(e, t) {
        return 1e3 * (e - d.SECS_70YRS + t / d.TWO_32);
    }, d.jsToNTPTime = function(e) {
        var e = e / 1e3, t = Math.floor(e);
        return [ t + d.SECS_70YRS, Math.round(d.TWO_32 * (e - t)) ];
    }, d.readArguments = function(e, t, r) {
        var n = d.readString(e, r);
        if (0 !== n.indexOf(",")) throw new Error("A malformed type tag string was found while reading the arguments of an OSC message. String was: " + n, " at offset: " + r.idx);
        var i = n.substring(1).split(""), o = [];
        return d.readArgumentsIntoArray(o, i, n, e, t, r), o;
    }, d.readArgument = function(e, t, r, n, i) {
        var o = d.argumentTypes[e];
        if (o) return o = o.reader, o = d[o](r, i), n.metadata ? {
            type: e,
            value: o
        } : o;
        throw new Error("'" + e + "' is not a valid OSC type tag. Type tag string was: " + t);
    }, d.readArgumentsIntoArray = function(e, t, r, n, i, o) {
        for (var a = 0; a < t.length; ) {
            var s = t[a];
            if ("[" === s) {
                var u = t.slice(a + 1), c = u.indexOf("]");
                if (c < 0) throw new Error("Invalid argument type tag: an open array type tag ('[') was found without a matching close array tag ('[]'). Type tag was: " + r);
                u = u.slice(0, c), u = d.readArgumentsIntoArray([], u, r, n, i, o);
                a += c + 2;
            } else u = d.readArgument(s, r, n, i, o), a++;
            e.push(u);
        }
        return e;
    }, d.writeArguments = function(e, t) {
        e = d.collectArguments(e, t);
        return d.joinParts(e);
    }, d.joinParts = function(e) {
        for (var t = new Uint8Array(e.byteLength), r = e.parts, n = 0, i = 0; i < r.length; i++) {
            var o = r[i];
            d.copyByteArray(o, t, n), n += o.length;
        }
        return t;
    }, d.addDataPart = function(e, t) {
        t.parts.push(e), t.byteLength += e.length;
    }, d.writeArrayArguments = function(e, t) {
        for (var r = "[", n = 0; n < e.length; n++) r += d.writeArgument(e[n], t);
        return r += "]";
    }, d.writeArgument = function(e, t) {
        var r;
        return d.isArray(e) ? d.writeArrayArguments(e, t) : (r = e.type, (r = d.argumentTypes[r].writer) && (r = d[r](e.value), 
        d.addDataPart(r, t)), e.type);
    }, d.collectArguments = function(e, t, r) {
        d.isArray(e) || (e = void 0 === e ? [] : [ e ]), r = r || {
            byteLength: 0,
            parts: []
        }, t.metadata || (e = d.annotateArguments(e));
        for (var n = ",", t = r.parts.length, i = 0; i < e.length; i++) {
            var o = e[i];
            n += d.writeArgument(o, r);
        }
        var a = d.writeString(n);
        return r.byteLength += a.byteLength, r.parts.splice(t, 0, a), r;
    }, d.readMessage = function(e, t, r) {
        t = t || d.defaults;
        var e = d.dataView(e, e.byteOffset, e.byteLength), n = d.readString(e, r = r || {
            idx: 0
        });
        return d.readMessageContents(n, e, t, r);
    }, d.readMessageContents = function(e, t, r, n) {
        if (0 !== e.indexOf("/")) throw new Error("A malformed OSC address was found while reading an OSC message. String was: " + e);
        t = d.readArguments(t, r, n);
        return {
            address: e,
            args: 1 === t.length && r.unpackSingleArgs ? t[0] : t
        };
    }, d.collectMessageParts = function(e, t, r) {
        return r = r || {
            byteLength: 0,
            parts: []
        }, d.addDataPart(d.writeString(e.address), r), d.collectArguments(e.args, t, r);
    }, d.writeMessage = function(e, t) {
        if (t = t || d.defaults, d.isValidMessage(e)) return t = d.collectMessageParts(e, t), 
        d.joinParts(t);
        throw new Error("An OSC message must contain a valid address. Message was: " + JSON.stringify(e, null, 2));
    }, d.isValidMessage = function(e) {
        return e.address && 0 === e.address.indexOf("/");
    }, d.readBundle = function(e, t, r) {
        return d.readPacket(e, t, r);
    }, d.collectBundlePackets = function(e, t, r) {
        r = r || {
            byteLength: 0,
            parts: []
        }, d.addDataPart(d.writeString("#bundle"), r), d.addDataPart(d.writeTimeTag(e.timeTag), r);
        for (var n = 0; n < e.packets.length; n++) {
            var i = e.packets[n], i = (i.address ? d.collectMessageParts : d.collectBundlePackets)(i, t);
            r.byteLength += i.byteLength, d.addDataPart(d.writeInt32(i.byteLength), r), 
            r.parts = r.parts.concat(i.parts);
        }
        return r;
    }, d.writeBundle = function(e, t) {
        if (!d.isValidBundle(e)) throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. Bundle was: " + JSON.stringify(e, null, 2));
        t = t || d.defaults;
        e = d.collectBundlePackets(e, t);
        return d.joinParts(e);
    }, d.isValidBundle = function(e) {
        return void 0 !== e.timeTag && void 0 !== e.packets;
    }, d.readBundleContents = function(e, t, r, n) {
        for (var i = d.readTimeTag(e, r), o = []; r.idx < n; ) {
            var a = d.readInt32(e, r), a = r.idx + a, a = d.readPacket(e, t, r, a);
            o.push(a);
        }
        return {
            timeTag: i,
            packets: o
        };
    }, d.readPacket = function(e, t, r, n) {
        var e = d.dataView(e, e.byteOffset, e.byteLength), i = (n = void 0 === n ? e.byteLength : n, 
        d.readString(e, r = r || {
            idx: 0
        })), o = i[0];
        if ("#" === o) return d.readBundleContents(e, t, r, n);
        if ("/" === o) return d.readMessageContents(i, e, t, r);
        throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string. Header was: " + i);
    }, d.writePacket = function(e, t) {
        if (d.isValidMessage(e)) return d.writeMessage(e, t);
        if (d.isValidBundle(e)) return d.writeBundle(e, t);
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle. Packet was: " + JSON.stringify(e, null, 2));
    }, d.argumentTypes = {
        i: {
            reader: "readInt32",
            writer: "writeInt32"
        },
        h: {
            reader: "readInt64",
            writer: "writeInt64"
        },
        f: {
            reader: "readFloat32",
            writer: "writeFloat32"
        },
        s: {
            reader: "readString",
            writer: "writeString"
        },
        S: {
            reader: "readString",
            writer: "writeString"
        },
        b: {
            reader: "readBlob",
            writer: "writeBlob"
        },
        t: {
            reader: "readTimeTag",
            writer: "writeTimeTag"
        },
        T: {
            reader: "readTrue"
        },
        F: {
            reader: "readFalse"
        },
        N: {
            reader: "readNull"
        },
        I: {
            reader: "readImpulse"
        },
        d: {
            reader: "readFloat64",
            writer: "writeFloat64"
        },
        c: {
            reader: "readChar32",
            writer: "writeChar32"
        },
        r: {
            reader: "readColor",
            writer: "writeColor"
        },
        m: {
            reader: "readMIDIBytes",
            writer: "writeMIDIBytes"
        }
    }, d.inferTypeForArgument = function(e) {
        switch (typeof e) {
          case "boolean":
            return e ? "T" : "F";

          case "string":
            return "s";

          case "number":
            return "f";

          case "undefined":
            return "N";

          case "object":
            if (null === e) return "N";
            if (e instanceof Uint8Array || e instanceof ArrayBuffer) return "b";
            if ("number" == typeof e.high && "number" == typeof e.low) return "h";
        }
        throw new Error("Can't infer OSC argument type for value: " + JSON.stringify(e, null, 2));
    }, d.annotateArguments = function(e) {
        for (var t = [], r = 0; r < e.length; r++) {
            var n = e[r];
            n = "object" == typeof n && n.type && void 0 !== n.value ? n : d.isArray(n) ? d.annotateArguments(n) : {
                type: d.inferTypeForArgument(n),
                value: n
            }, t.push(n);
        }
        return t;
    }, d.isCommonJS && (module.exports = d);
    var d = d || require("./osc.js"), n = n || require("slip"), t = t || require("events").EventEmitter;
    return d.supportsSerial = !1, d.firePacketEvents = function(e, t, r, n) {
        t.address ? e.emit("message", t, r, n) : d.fireBundleEvents(e, t, r, n);
    }, d.fireBundleEvents = function(e, t, r, n) {
        e.emit("bundle", t, r, n);
        for (var i = 0; i < t.packets.length; i++) {
            var o = t.packets[i];
            d.firePacketEvents(e, o, t.timeTag, n);
        }
    }, d.fireClosedPortSendError = function(e, t) {
        e.emit("error", t = t || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().");
    }, d.Port = function(e) {
        this.options = e || {}, this.on("data", this.decodeOSC.bind(this));
    }, (r = d.Port.prototype = Object.create(t.prototype)).constructor = d.Port, 
    r.send = function(e) {
        var t = Array.prototype.slice.call(arguments), e = this.encodeOSC(e), e = d.nativeBuffer(e);
        t[0] = e, this.sendRaw.apply(this, t);
    }, r.encodeOSC = function(e) {
        var t;
        e = e.buffer || e;
        try {
            t = d.writePacket(e, this.options);
        } catch (e) {
            this.emit("error", e);
        }
        return t;
    }, r.decodeOSC = function(e, t) {
        e = d.byteArray(e), this.emit("raw", e, t);
        try {
            var r = d.readPacket(e, this.options);
            this.emit("osc", r, t), d.firePacketEvents(this, r, void 0, t);
        } catch (e) {
            this.emit("error", e);
        }
    }, d.SLIPPort = function(e) {
        var t = this, e = this.options = e || {}, e = (e.useSLIP = void 0 === e.useSLIP || e.useSLIP, 
        this.decoder = new n.Decoder({
            onMessage: this.decodeOSC.bind(this),
            onError: function(e) {
                t.emit("error", e);
            }
        }), e.useSLIP ? this.decodeSLIPData : this.decodeOSC);
        this.on("data", e.bind(this));
    }, (r = d.SLIPPort.prototype = Object.create(d.Port.prototype)).constructor = d.SLIPPort, 
    r.encodeOSC = function(e) {
        e = e.buffer || e;
        try {
            var t = d.writePacket(e, this.options), r = n.encode(t);
        } catch (e) {
            this.emit("error", e);
        }
        return r;
    }, r.decodeSLIPData = function(e, t) {
        this.decoder.decode(e, t);
    }, d.relay = function(e, t, r, n, i, o) {
        r = r || "message", n = n || "send", i = i || function() {}, o = o ? [ null ].concat(o) : [];
        function a(e) {
            o[0] = e, e = i(e), t[n].apply(t, o);
        }
        return e.on(r, a), {
            eventName: r,
            listener: a
        };
    }, d.relayPorts = function(e, t, r) {
        var n = r.raw ? "raw" : "osc";
        return d.relay(e, t, n, r.raw ? "sendRaw" : "send", r.transform);
    }, d.stopRelaying = function(e, t) {
        e.removeListener(t.eventName, t.listener);
    }, d.Relay = function(e, t, r) {
        (this.options = r || {}).raw = !1, this.port1 = e, this.port2 = t, this.listen();
    }, (r = d.Relay.prototype = Object.create(t.prototype)).constructor = d.Relay, 
    r.open = function() {
        this.port1.open(), this.port2.open();
    }, r.listen = function() {
        this.port1Spec && this.port2Spec && this.close(), this.port1Spec = d.relayPorts(this.port1, this.port2, this.options), 
        this.port2Spec = d.relayPorts(this.port2, this.port1, this.options);
        var e = this.close.bind(this);
        this.port1.on("close", e), this.port2.on("close", e);
    }, r.close = function() {
        d.stopRelaying(this.port1, this.port1Spec), d.stopRelaying(this.port2, this.port2Spec), 
        this.emit("close", this.port1, this.port2);
    }, "undefined" != typeof module && module.exports && (module.exports = d), (d = d || require("./osc.js")).WebSocket = "undefined" != typeof WebSocket ? WebSocket : require("ws"), 
    d.WebSocketPort = function(e) {
        d.Port.call(this, e), this.on("open", this.listen.bind(this)), this.socket = e.socket, 
        this.socket && (1 === this.socket.readyState ? (d.WebSocketPort.setupSocketForBinary(this.socket), 
        this.emit("open", this.socket)) : this.open());
    }, (t = d.WebSocketPort.prototype = Object.create(d.Port.prototype)).constructor = d.WebSocketPort, 
    t.open = function() {
        (!this.socket || 1 < this.socket.readyState) && (this.socket = new d.WebSocket(this.options.url)), 
        d.WebSocketPort.setupSocketForBinary(this.socket);
        var t = this;
        this.socket.onopen = function() {
            t.emit("open", t.socket);
        }, this.socket.onerror = function(e) {
            t.emit("error", e);
        };
    }, t.listen = function() {
        var t = this;
        this.socket.onmessage = function(e) {
            t.emit("data", e.data, e);
        }, this.socket.onclose = function(e) {
            t.emit("close", e);
        }, t.emit("ready");
    }, t.sendRaw = function(e) {
        this.socket && 1 === this.socket.readyState ? this.socket.send(e) : d.fireClosedPortSendError(this);
    }, t.close = function(e, t) {
        this.socket.close(e, t);
    }, d.WebSocketPort.setupSocketForBinary = function(e) {
        e.binaryType = d.isNode ? "nodebuffer" : "arraybuffer";
    }, (d = d || require("./osc.js")).supportsSerial = !0, d.SerialPort = function(e) {
        if (!("serial" in navigator)) throw Error("Web serial not supported in your browser. Check https://developer.mozilla.org/en-US/docs/Web/API/Web_Serial_API#browser_compatibility for more info.");
        this.on("open", this.listen.bind(this)), d.SLIPPort.call(this, e), this.options.bitrate = this.options.bitrate || 9600, 
        this.serialPort = e.serialPort, this.serialPort && this.emit("open", this.serialPort);
    }, (r = d.SerialPort.prototype = Object.create(d.SLIPPort.prototype)).constructor = d.SerialPort, 
    r.open = async function() {
        if (this.serialPort) this.once("close", this.open.bind(this)), this.close(); else try {
            this.serialPort = await navigator.serial.requestPort(), await this.serialPort.open(this.options), 
            this.serialPort.isOpen = !0, this.emit("open", this.serialPort);
        } catch (e) {
            this.serialPort.isOpen = !1, this.emit("error", e);
        }
    }, r.listen = async function() {
        for (;this.serialPort.readable; ) {
            var e = this.serialPort.readable.getReader();
            try {
                for (;;) {
                    var {
                        value: t,
                        done: r
                    } = await e.read();
                    if (r) break;
                    this.emit("data", t, void 0);
                }
            } catch (e) {
                this.emit("error", e);
            } finally {
                e.releaseLock();
            }
        }
        this.emit("ready");
    }, r.messageQueue = [], r.isWriting = !1, r.sendRaw = async function(e) {
        if (this.serialPort && this.serialPort.isOpen) {
            if (this.messageQueue.push(e), !this.isWriting) {
                this.isWriting = !0;
                for (var t = this.serialPort.writable.getWriter(); 0 < this.messageQueue.length; ) {
                    var r = this.messageQueue.shift();
                    try {
                        await t.write(r);
                    } catch (e) {
                        console.error(e), this.emit("error", e);
                    }
                }
                t.releaseLock(), this.isWriting = !1;
            }
        } else d.fireClosedPortSendError(this);
    }, r.close = function() {
        this.serialPort && (this.serialPort.close(), this.serialPort.isOpen = !1);
    }, d;
});