/*! osc.js 2.4.5, Copyright 2024 Colin Clark | github.com/colinbdclark/osc.js */
var osc = osc || {};

osc.SECS_70YRS = 2208988800, osc.TWO_32 = 4294967296, osc.defaults = {
    metadata: !1,
    unpackSingleArgs: !0
}, osc.isCommonJS = !("undefined" == typeof module || !module.exports), osc.isNode = osc.isCommonJS && "undefined" == typeof window, 
osc.isElectron = !("undefined" == typeof process || !process.versions || !process.versions.electron), 
osc.isBufferEnv = osc.isNode || osc.isElectron, osc.isArray = function(e) {
    return e && "[object Array]" === Object.prototype.toString.call(e);
}, osc.isTypedArrayView = function(e) {
    return e.buffer && e.buffer instanceof ArrayBuffer;
}, osc.isBuffer = function(e) {
    return osc.isBufferEnv && e instanceof Buffer;
}, osc.Long = "undefined" != typeof Long ? Long : osc.isNode ? require("long") : void 0, 
osc.TextDecoder = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : "undefined" != typeof util && (util.TextDecoder, 
1) ? new util.TextDecoder("utf-8") : void 0, osc.TextEncoder = "undefined" != typeof TextEncoder ? new TextEncoder("utf-8") : "undefined" != typeof util && (util.TextEncoder, 
1) ? new util.TextEncoder("utf-8") : void 0, osc.dataView = function(e, r, t) {
    return e.buffer ? new DataView(e.buffer, r, t) : e instanceof ArrayBuffer ? new DataView(e, r, t) : new DataView(new Uint8Array(e), r, t);
}, osc.byteArray = function(e) {
    if (e instanceof Uint8Array) return e;
    var r = e.buffer || e;
    if (r instanceof ArrayBuffer || void 0 !== r.length && "string" != typeof r) return new Uint8Array(r);
    throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " + JSON.stringify(e, null, 2));
}, osc.nativeBuffer = function(e) {
    return osc.isBufferEnv ? osc.isBuffer(e) ? e : Buffer.from(e.buffer ? e : new Uint8Array(e)) : osc.isTypedArrayView(e) ? e : new Uint8Array(e);
}, osc.copyByteArray = function(e, r, t) {
    if (osc.isTypedArrayView(e) && osc.isTypedArrayView(r)) r.set(e, t); else for (var n = void 0 === t ? 0 : t, o = Math.min(r.length - t, e.length), a = 0, i = n; a < o; a++, 
    i++) r[i] = e[a];
    return r;
}, osc.readString = function(e, r) {
    for (var t = [], n = r.idx; n < e.byteLength; n++) {
        var o = e.getUint8(n);
        if (0 === o) {
            n++;
            break;
        }
        t.push(o);
    }
    return r.idx = n = n + 3 & -4, (osc.isBufferEnv ? osc.readString.withBuffer : osc.TextDecoder ? osc.readString.withTextDecoder : osc.readString.raw)(t);
}, osc.readString.raw = function(e) {
    for (var r = "", t = 0; t < e.length; t += 1e4) r += String.fromCharCode.apply(null, e.slice(t, t + 1e4));
    return r;
}, osc.readString.withTextDecoder = function(e) {
    e = new Int8Array(e);
    return osc.TextDecoder.decode(e);
}, osc.readString.withBuffer = function(e) {
    return Buffer.from(e).toString("utf-8");
}, osc.writeString = function(e) {
    for (var r, t = osc.isBufferEnv ? osc.writeString.withBuffer : osc.TextEncoder ? osc.writeString.withTextEncoder : null, n = e + "\0", o = (t && (r = t(n)), 
    (t ? r : n).length), a = new Uint8Array(o + 3 & -4), i = 0; i < o - 1; i++) {
        var s = t ? r[i] : n.charCodeAt(i);
        a[i] = s;
    }
    return a;
}, osc.writeString.withTextEncoder = function(e) {
    return osc.TextEncoder.encode(e);
}, osc.writeString.withBuffer = function(e) {
    return Buffer.from(e);
}, osc.readPrimitive = function(e, r, t, n) {
    e = e[r](n.idx, !1);
    return n.idx += t, e;
}, osc.writePrimitive = function(e, r, t, n, o) {
    var a;
    return o = void 0 === o ? 0 : o, r ? a = new Uint8Array(r.buffer) : (a = new Uint8Array(n), 
    r = new DataView(a.buffer)), r[t](o, e, !1), a;
}, osc.readInt32 = function(e, r) {
    return osc.readPrimitive(e, "getInt32", 4, r);
}, osc.writeInt32 = function(e, r, t) {
    return osc.writePrimitive(e, r, "setInt32", 4, t);
}, osc.readInt64 = function(e, r) {
    var t = osc.readPrimitive(e, "getInt32", 4, r), e = osc.readPrimitive(e, "getInt32", 4, r);
    return osc.Long ? new osc.Long(e, t) : {
        high: t,
        low: e,
        unsigned: !1
    };
}, osc.writeInt64 = function(e, r, t) {
    var n = new Uint8Array(8);
    return n.set(osc.writePrimitive(e.high, r, "setInt32", 4, t), 0), n.set(osc.writePrimitive(e.low, r, "setInt32", 4, t + 4), 4), 
    n;
}, osc.readFloat32 = function(e, r) {
    return osc.readPrimitive(e, "getFloat32", 4, r);
}, osc.writeFloat32 = function(e, r, t) {
    return osc.writePrimitive(e, r, "setFloat32", 4, t);
}, osc.readFloat64 = function(e, r) {
    return osc.readPrimitive(e, "getFloat64", 8, r);
}, osc.writeFloat64 = function(e, r, t) {
    return osc.writePrimitive(e, r, "setFloat64", 8, t);
}, osc.readChar32 = function(e, r) {
    e = osc.readPrimitive(e, "getUint32", 4, r);
    return String.fromCharCode(e);
}, osc.writeChar32 = function(e, r, t) {
    e = e.charCodeAt(0);
    if (!(void 0 === e || e < -1)) return osc.writePrimitive(e, r, "setUint32", 4, t);
}, osc.readBlob = function(e, r) {
    var t = osc.readInt32(e, r), n = t + 3 & -4, e = new Uint8Array(e.buffer, r.idx, t);
    return r.idx += n, e;
}, osc.writeBlob = function(e) {
    var r = (e = osc.byteArray(e)).byteLength, t = new Uint8Array(4 + (r + 3 & -4)), n = new DataView(t.buffer);
    return osc.writeInt32(r, n), t.set(e, 4), t;
}, osc.readMIDIBytes = function(e, r) {
    e = new Uint8Array(e.buffer, r.idx, 4);
    return r.idx += 4, e;
}, osc.writeMIDIBytes = function(e) {
    e = osc.byteArray(e);
    var r = new Uint8Array(4);
    return r.set(e), r;
}, osc.readColor = function(e, r) {
    var e = new Uint8Array(e.buffer, r.idx, 4), t = e[3] / 255;
    return r.idx += 4, {
        r: e[0],
        g: e[1],
        b: e[2],
        a: t
    };
}, osc.writeColor = function(e) {
    var r = Math.round(255 * e.a);
    return new Uint8Array([ e.r, e.g, e.b, r ]);
}, osc.readTrue = function() {
    return !0;
}, osc.readFalse = function() {
    return !1;
}, osc.readNull = function() {
    return null;
}, osc.readImpulse = function() {
    return 1;
}, osc.readTimeTag = function(e, r) {
    var t = osc.readPrimitive(e, "getUint32", 4, r), e = osc.readPrimitive(e, "getUint32", 4, r);
    return {
        raw: [ t, e ],
        native: 0 === t && 1 === e ? Date.now() : osc.ntpToJSTime(t, e)
    };
}, osc.writeTimeTag = function(e) {
    var e = e.raw || osc.jsToNTPTime(e.native), r = new Uint8Array(8), t = new DataView(r.buffer);
    return osc.writeInt32(e[0], t, 0), osc.writeInt32(e[1], t, 4), r;
}, osc.timeTag = function(e, r) {
    e = e || 0;
    var r = (r = r || Date.now()) / 1e3, t = Math.floor(r), r = r - t, n = Math.floor(e), r = r + (e - n);
    return 1 < r && (n += e = Math.floor(r), r = r - e), {
        raw: [ t + n + osc.SECS_70YRS, Math.round(osc.TWO_32 * r) ]
    };
}, osc.ntpToJSTime = function(e, r) {
    return 1e3 * (e - osc.SECS_70YRS + r / osc.TWO_32);
}, osc.jsToNTPTime = function(e) {
    var e = e / 1e3, r = Math.floor(e);
    return [ r + osc.SECS_70YRS, Math.round(osc.TWO_32 * (e - r)) ];
}, osc.readArguments = function(e, r, t) {
    var n = osc.readString(e, t);
    if (0 !== n.indexOf(",")) throw new Error("A malformed type tag string was found while reading the arguments of an OSC message. String was: " + n, " at offset: " + t.idx);
    var o = n.substring(1).split(""), a = [];
    return osc.readArgumentsIntoArray(a, o, n, e, r, t), a;
}, osc.readArgument = function(e, r, t, n, o) {
    var a = osc.argumentTypes[e];
    if (a) return a = a.reader, a = osc[a](t, o), n.metadata ? {
        type: e,
        value: a
    } : a;
    throw new Error("'" + e + "' is not a valid OSC type tag. Type tag string was: " + r);
}, osc.readArgumentsIntoArray = function(e, r, t, n, o, a) {
    for (var i = 0; i < r.length; ) {
        var s = r[i];
        if ("[" === s) {
            var c = r.slice(i + 1), u = c.indexOf("]");
            if (u < 0) throw new Error("Invalid argument type tag: an open array type tag ('[') was found without a matching close array tag ('[]'). Type tag was: " + t);
            c = c.slice(0, u), c = osc.readArgumentsIntoArray([], c, t, n, o, a);
            i += u + 2;
        } else c = osc.readArgument(s, t, n, o, a), i++;
        e.push(c);
    }
    return e;
}, osc.writeArguments = function(e, r) {
    e = osc.collectArguments(e, r);
    return osc.joinParts(e);
}, osc.joinParts = function(e) {
    for (var r = new Uint8Array(e.byteLength), t = e.parts, n = 0, o = 0; o < t.length; o++) {
        var a = t[o];
        osc.copyByteArray(a, r, n), n += a.length;
    }
    return r;
}, osc.addDataPart = function(e, r) {
    r.parts.push(e), r.byteLength += e.length;
}, osc.writeArrayArguments = function(e, r) {
    for (var t = "[", n = 0; n < e.length; n++) t += osc.writeArgument(e[n], r);
    return t += "]";
}, osc.writeArgument = function(e, r) {
    var t;
    return osc.isArray(e) ? osc.writeArrayArguments(e, r) : (t = e.type, (t = osc.argumentTypes[t].writer) && (t = osc[t](e.value), 
    osc.addDataPart(t, r)), e.type);
}, osc.collectArguments = function(e, r, t) {
    osc.isArray(e) || (e = void 0 === e ? [] : [ e ]), t = t || {
        byteLength: 0,
        parts: []
    }, r.metadata || (e = osc.annotateArguments(e));
    for (var n = ",", r = t.parts.length, o = 0; o < e.length; o++) {
        var a = e[o];
        n += osc.writeArgument(a, t);
    }
    var i = osc.writeString(n);
    return t.byteLength += i.byteLength, t.parts.splice(r, 0, i), t;
}, osc.readMessage = function(e, r, t) {
    r = r || osc.defaults;
    var e = osc.dataView(e, e.byteOffset, e.byteLength), n = osc.readString(e, t = t || {
        idx: 0
    });
    return osc.readMessageContents(n, e, r, t);
}, osc.readMessageContents = function(e, r, t, n) {
    if (0 !== e.indexOf("/")) throw new Error("A malformed OSC address was found while reading an OSC message. String was: " + e);
    r = osc.readArguments(r, t, n);
    return {
        address: e,
        args: 1 === r.length && t.unpackSingleArgs ? r[0] : r
    };
}, osc.collectMessageParts = function(e, r, t) {
    return t = t || {
        byteLength: 0,
        parts: []
    }, osc.addDataPart(osc.writeString(e.address), t), osc.collectArguments(e.args, r, t);
}, osc.writeMessage = function(e, r) {
    if (r = r || osc.defaults, osc.isValidMessage(e)) return r = osc.collectMessageParts(e, r), 
    osc.joinParts(r);
    throw new Error("An OSC message must contain a valid address. Message was: " + JSON.stringify(e, null, 2));
}, osc.isValidMessage = function(e) {
    return e.address && 0 === e.address.indexOf("/");
}, osc.readBundle = function(e, r, t) {
    return osc.readPacket(e, r, t);
}, osc.collectBundlePackets = function(e, r, t) {
    t = t || {
        byteLength: 0,
        parts: []
    }, osc.addDataPart(osc.writeString("#bundle"), t), osc.addDataPart(osc.writeTimeTag(e.timeTag), t);
    for (var n = 0; n < e.packets.length; n++) {
        var o = e.packets[n], o = (o.address ? osc.collectMessageParts : osc.collectBundlePackets)(o, r);
        t.byteLength += o.byteLength, osc.addDataPart(osc.writeInt32(o.byteLength), t), 
        t.parts = t.parts.concat(o.parts);
    }
    return t;
}, osc.writeBundle = function(e, r) {
    if (!osc.isValidBundle(e)) throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. Bundle was: " + JSON.stringify(e, null, 2));
    r = r || osc.defaults;
    e = osc.collectBundlePackets(e, r);
    return osc.joinParts(e);
}, osc.isValidBundle = function(e) {
    return void 0 !== e.timeTag && void 0 !== e.packets;
}, osc.readBundleContents = function(e, r, t, n) {
    for (var o = osc.readTimeTag(e, t), a = []; t.idx < n; ) {
        var i = osc.readInt32(e, t), i = t.idx + i, i = osc.readPacket(e, r, t, i);
        a.push(i);
    }
    return {
        timeTag: o,
        packets: a
    };
}, osc.readPacket = function(e, r, t, n) {
    var e = osc.dataView(e, e.byteOffset, e.byteLength), o = (n = void 0 === n ? e.byteLength : n, 
    osc.readString(e, t = t || {
        idx: 0
    })), a = o[0];
    if ("#" === a) return osc.readBundleContents(e, r, t, n);
    if ("/" === a) return osc.readMessageContents(o, e, r, t);
    throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string. Header was: " + o);
}, osc.writePacket = function(e, r) {
    if (osc.isValidMessage(e)) return osc.writeMessage(e, r);
    if (osc.isValidBundle(e)) return osc.writeBundle(e, r);
    throw new Error("The specified packet was not recognized as a valid OSC message or bundle. Packet was: " + JSON.stringify(e, null, 2));
}, osc.argumentTypes = {
    i: {
        reader: "readInt32",
        writer: "writeInt32"
    },
    h: {
        reader: "readInt64",
        writer: "writeInt64"
    },
    f: {
        reader: "readFloat32",
        writer: "writeFloat32"
    },
    s: {
        reader: "readString",
        writer: "writeString"
    },
    S: {
        reader: "readString",
        writer: "writeString"
    },
    b: {
        reader: "readBlob",
        writer: "writeBlob"
    },
    t: {
        reader: "readTimeTag",
        writer: "writeTimeTag"
    },
    T: {
        reader: "readTrue"
    },
    F: {
        reader: "readFalse"
    },
    N: {
        reader: "readNull"
    },
    I: {
        reader: "readImpulse"
    },
    d: {
        reader: "readFloat64",
        writer: "writeFloat64"
    },
    c: {
        reader: "readChar32",
        writer: "writeChar32"
    },
    r: {
        reader: "readColor",
        writer: "writeColor"
    },
    m: {
        reader: "readMIDIBytes",
        writer: "writeMIDIBytes"
    }
}, osc.inferTypeForArgument = function(e) {
    switch (typeof e) {
      case "boolean":
        return e ? "T" : "F";

      case "string":
        return "s";

      case "number":
        return "f";

      case "undefined":
        return "N";

      case "object":
        if (null === e) return "N";
        if (e instanceof Uint8Array || e instanceof ArrayBuffer) return "b";
        if ("number" == typeof e.high && "number" == typeof e.low) return "h";
    }
    throw new Error("Can't infer OSC argument type for value: " + JSON.stringify(e, null, 2));
}, osc.annotateArguments = function(e) {
    for (var r = [], t = 0; t < e.length; t++) {
        var n = e[t];
        n = "object" == typeof n && n.type && void 0 !== n.value ? n : osc.isArray(n) ? osc.annotateArguments(n) : {
            type: osc.inferTypeForArgument(n),
            value: n
        }, r.push(n);
    }
    return r;
}, osc.isCommonJS && (module.exports = osc);