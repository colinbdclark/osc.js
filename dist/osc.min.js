/*! osc.js 2.2.4, Copyright 2018 Colin Clark | github.com/colinbdclark/osc.js */


var osc = osc || {};

!function() {
    "use strict";
    osc.SECS_70YRS = 2208988800, osc.TWO_32 = 4294967296, osc.defaults = {
        metadata: !1,
        unpackSingleArgs: !0
    }, osc.isCommonJS = !("undefined" == typeof module || !module.exports), osc.isNode = osc.isCommonJS && "undefined" == typeof window, 
    osc.isElectron = !("undefined" == typeof process || !process.versions || !process.versions.electron), 
    osc.isBufferEnv = osc.isNode || osc.isElectron, osc.isArray = function(r) {
        return r && "[object Array]" === Object.prototype.toString.call(r);
    }, osc.isTypedArrayView = function(r) {
        return r.buffer && r.buffer instanceof ArrayBuffer;
    }, osc.isBuffer = function(r) {
        return osc.isBufferEnv && r instanceof Buffer;
    }, osc.Long = "undefined" != typeof Long ? Long : osc.isNode ? require("long") : void 0, 
    osc.dataView = function(r, e, t) {
        return r.buffer ? new DataView(r.buffer, e, t) : r instanceof ArrayBuffer ? new DataView(r, e, t) : new DataView(new Uint8Array(r), e, t);
    }, osc.byteArray = function(r) {
        if (r instanceof Uint8Array) return r;
        var e = r.buffer ? r.buffer : r;
        if (!(e instanceof ArrayBuffer || void 0 !== e.length && "string" != typeof e)) throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " + JSON.stringify(r, null, 2));
        return new Uint8Array(e);
    }, osc.nativeBuffer = function(r) {
        return osc.isBufferEnv ? osc.isBuffer(r) ? r : new Buffer(r.buffer ? r : new Uint8Array(r)) : osc.isTypedArrayView(r) ? r : new Uint8Array(r);
    }, osc.copyByteArray = function(r, e, t) {
        if (osc.isTypedArrayView(r) && osc.isTypedArrayView(e)) e.set(r, t); else for (var n = void 0 === t ? 0 : t, a = Math.min(e.length - t, r.length), o = 0, s = n; o < a; o++, 
        s++) e[s] = r[o];
        return e;
    }, osc.readString = function(r, e) {
        for (var t = [], n = e.idx; n < r.byteLength; n++) {
            var a = r.getUint8(n);
            if (0 === a) {
                n++;
                break;
            }
            t.push(a);
        }
        return n = n + 3 & -4, e.idx = n, String.fromCharCode.apply(null, t);
    }, osc.writeString = function(r) {
        for (var e = r + "\0", t = e.length, n = new Uint8Array(t + 3 & -4), a = 0; a < e.length; a++) {
            var o = e.charCodeAt(a);
            n[a] = o;
        }
        return n;
    }, osc.readPrimitive = function(r, e, t, n) {
        var a = r[e](n.idx, !1);
        return n.idx += t, a;
    }, osc.writePrimitive = function(r, e, t, n, a) {
        var o;
        return a = void 0 === a ? 0 : a, e ? o = new Uint8Array(e.buffer) : (o = new Uint8Array(n), 
        e = new DataView(o.buffer)), e[t](a, r, !1), o;
    }, osc.readInt32 = function(r, e) {
        return osc.readPrimitive(r, "getInt32", 4, e);
    }, osc.writeInt32 = function(r, e, t) {
        return osc.writePrimitive(r, e, "setInt32", 4, t);
    }, osc.readInt64 = function(r, e) {
        var t = osc.readPrimitive(r, "getInt32", 4, e), n = osc.readPrimitive(r, "getInt32", 4, e);
        return osc.Long ? new osc.Long(n, t) : {
            high: t,
            low: n,
            unsigned: !1
        };
    }, osc.writeInt64 = function(r, e, t) {
        var n = new Uint8Array(8);
        return n.set(osc.writePrimitive(r.high, e, "setInt32", 4, t), 0), n.set(osc.writePrimitive(r.low, e, "setInt32", 4, t + 4), 4), 
        n;
    }, osc.readFloat32 = function(r, e) {
        return osc.readPrimitive(r, "getFloat32", 4, e);
    }, osc.writeFloat32 = function(r, e, t) {
        return osc.writePrimitive(r, e, "setFloat32", 4, t);
    }, osc.readFloat64 = function(r, e) {
        return osc.readPrimitive(r, "getFloat64", 8, e);
    }, osc.writeFloat64 = function(r, e, t) {
        return osc.writePrimitive(r, e, "setFloat64", 8, t);
    }, osc.readChar32 = function(r, e) {
        var t = osc.readPrimitive(r, "getUint32", 4, e);
        return String.fromCharCode(t);
    }, osc.writeChar32 = function(r, e, t) {
        var n = r.charCodeAt(0);
        if (!(void 0 === n || n < -1)) return osc.writePrimitive(n, e, "setUint32", 4, t);
    }, osc.readBlob = function(r, e) {
        var t = osc.readInt32(r, e), n = t + 3 & -4, a = new Uint8Array(r.buffer, e.idx, t);
        return e.idx += n, a;
    }, osc.writeBlob = function(r) {
        var e = (r = osc.byteArray(r)).byteLength, t = new Uint8Array((e + 3 & -4) + 4), n = new DataView(t.buffer);
        return osc.writeInt32(e, n), t.set(r, 4), t;
    }, osc.readMIDIBytes = function(r, e) {
        var t = new Uint8Array(r.buffer, e.idx, 4);
        return e.idx += 4, t;
    }, osc.writeMIDIBytes = function(r) {
        r = osc.byteArray(r);
        var e = new Uint8Array(4);
        return e.set(r), e;
    }, osc.readColor = function(r, e) {
        var t = new Uint8Array(r.buffer, e.idx, 4), n = t[3] / 255;
        return e.idx += 4, {
            r: t[0],
            g: t[1],
            b: t[2],
            a: n
        };
    }, osc.writeColor = function(r) {
        var e = Math.round(255 * r.a);
        return new Uint8Array([ r.r, r.g, r.b, e ]);
    }, osc.readTrue = function() {
        return !0;
    }, osc.readFalse = function() {
        return !1;
    }, osc.readNull = function() {
        return null;
    }, osc.readImpulse = function() {
        return 1;
    }, osc.readTimeTag = function(r, e) {
        var t = osc.readPrimitive(r, "getUint32", 4, e), n = osc.readPrimitive(r, "getUint32", 4, e);
        return {
            raw: [ t, n ],
            native: 0 === t && 1 === n ? Date.now() : osc.ntpToJSTime(t, n)
        };
    }, osc.writeTimeTag = function(r) {
        var e = r.raw ? r.raw : osc.jsToNTPTime(r.native), t = new Uint8Array(8), n = new DataView(t.buffer);
        return osc.writeInt32(e[0], n, 0), osc.writeInt32(e[1], n, 4), t;
    }, osc.timeTag = function(r, e) {
        r = r || 0;
        var t = (e = e || Date.now()) / 1e3, n = Math.floor(t), a = t - n, o = Math.floor(r), s = a + (r - o);
        if (s > 1) {
            var i = Math.floor(s);
            o += i, s = s - i;
        }
        return {
            raw: [ n + o + osc.SECS_70YRS, Math.round(osc.TWO_32 * s) ]
        };
    }, osc.ntpToJSTime = function(r, e) {
        return 1e3 * (r - osc.SECS_70YRS + e / osc.TWO_32);
    }, osc.jsToNTPTime = function(r) {
        var e = r / 1e3, t = Math.floor(e), n = e - t;
        return [ t + osc.SECS_70YRS, Math.round(osc.TWO_32 * n) ];
    }, osc.readArguments = function(r, e, t) {
        var n = osc.readString(r, t);
        if (0 !== n.indexOf(",")) throw new Error("A malformed type tag string was found while reading the arguments of an OSC message. String was: " + n, " at offset: " + t.idx);
        var a = n.substring(1).split(""), o = [];
        return osc.readArgumentsIntoArray(o, a, n, r, e, t), o;
    }, osc.readArgument = function(r, e, t, n, a) {
        var o = osc.argumentTypes[r];
        if (!o) throw new Error("'" + r + "' is not a valid OSC type tag. Type tag string was: " + e);
        var s = o.reader, i = osc[s](t, a);
        return n.metadata && (i = {
            type: r,
            value: i
        }), i;
    }, osc.readArgumentsIntoArray = function(r, e, t, n, a, o) {
        for (var s = 0; s < e.length; ) {
            var i, c = e[s];
            if ("[" === c) {
                var u = e.slice(s + 1), d = u.indexOf("]");
                if (d < 0) throw new Error("Invalid argument type tag: an open array type tag ('[') was found without a matching close array tag ('[]'). Type tag was: " + t);
                var f = u.slice(0, d);
                i = osc.readArgumentsIntoArray([], f, t, n, a, o), s += d + 2;
            } else i = osc.readArgument(c, t, n, a, o), s++;
            r.push(i);
        }
        return r;
    }, osc.writeArguments = function(r, e) {
        var t = osc.collectArguments(r, e);
        return osc.joinParts(t);
    }, osc.joinParts = function(r) {
        for (var e = new Uint8Array(r.byteLength), t = r.parts, n = 0, a = 0; a < t.length; a++) {
            var o = t[a];
            osc.copyByteArray(o, e, n), n += o.length;
        }
        return e;
    }, osc.addDataPart = function(r, e) {
        e.parts.push(r), e.byteLength += r.length;
    }, osc.writeArrayArguments = function(r, e) {
        for (var t = "[", n = 0; n < r.length; n++) {
            var a = r[n];
            t += osc.writeArgument(a, e);
        }
        return t += "]";
    }, osc.writeArgument = function(r, e) {
        if (osc.isArray(r)) return osc.writeArrayArguments(r, e);
        var t = r.type, n = osc.argumentTypes[t].writer;
        if (n) {
            var a = osc[n](r.value);
            osc.addDataPart(a, e);
        }
        return r.type;
    }, osc.collectArguments = function(r, e, t) {
        osc.isArray(r) || (r = void 0 === r ? [] : [ r ]), t = t || {
            byteLength: 0,
            parts: []
        }, e.metadata || (r = osc.annotateArguments(r));
        for (var n = ",", a = t.parts.length, o = 0; o < r.length; o++) {
            var s = r[o];
            n += osc.writeArgument(s, t);
        }
        var i = osc.writeString(n);
        return t.byteLength += i.byteLength, t.parts.splice(a, 0, i), t;
    }, osc.readMessage = function(r, e, t) {
        e = e || osc.defaults;
        var n = osc.dataView(r, r.byteOffset, r.byteLength);
        t = t || {
            idx: 0
        };
        var a = osc.readString(n, t);
        return osc.readMessageContents(a, n, e, t);
    }, osc.readMessageContents = function(r, e, t, n) {
        if (0 !== r.indexOf("/")) throw new Error("A malformed OSC address was found while reading an OSC message. String was: " + r);
        var a = osc.readArguments(e, t, n);
        return {
            address: r,
            args: 1 === a.length && t.unpackSingleArgs ? a[0] : a
        };
    }, osc.collectMessageParts = function(r, e, t) {
        return t = t || {
            byteLength: 0,
            parts: []
        }, osc.addDataPart(osc.writeString(r.address), t), osc.collectArguments(r.args, e, t);
    }, osc.writeMessage = function(r, e) {
        if (e = e || osc.defaults, !osc.isValidMessage(r)) throw new Error("An OSC message must contain a valid address. Message was: " + JSON.stringify(r, null, 2));
        var t = osc.collectMessageParts(r, e);
        return osc.joinParts(t);
    }, osc.isValidMessage = function(r) {
        return r.address && 0 === r.address.indexOf("/");
    }, osc.readBundle = function(r, e, t) {
        return osc.readPacket(r, e, t);
    }, osc.collectBundlePackets = function(r, e, t) {
        t = t || {
            byteLength: 0,
            parts: []
        }, osc.addDataPart(osc.writeString("#bundle"), t), osc.addDataPart(osc.writeTimeTag(r.timeTag), t);
        for (var n = 0; n < r.packets.length; n++) {
            var a = r.packets[n], o = (a.address ? osc.collectMessageParts : osc.collectBundlePackets)(a, e);
            t.byteLength += o.byteLength, osc.addDataPart(osc.writeInt32(o.byteLength), t), 
            t.parts = t.parts.concat(o.parts);
        }
        return t;
    }, osc.writeBundle = function(r, e) {
        if (!osc.isValidBundle(r)) throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. Bundle was: " + JSON.stringify(r, null, 2));
        e = e || osc.defaults;
        var t = osc.collectBundlePackets(r, e);
        return osc.joinParts(t);
    }, osc.isValidBundle = function(r) {
        return void 0 !== r.timeTag && void 0 !== r.packets;
    }, osc.readBundleContents = function(r, e, t, n) {
        for (var a = osc.readTimeTag(r, t), o = []; t.idx < n; ) {
            var s = osc.readInt32(r, t), i = t.idx + s, c = osc.readPacket(r, e, t, i);
            o.push(c);
        }
        return {
            timeTag: a,
            packets: o
        };
    }, osc.readPacket = function(r, e, t, n) {
        var a = osc.dataView(r, r.byteOffset, r.byteLength);
        n = void 0 === n ? a.byteLength : n, t = t || {
            idx: 0
        };
        var o = osc.readString(a, t), s = o[0];
        if ("#" === s) return osc.readBundleContents(a, e, t, n);
        if ("/" === s) return osc.readMessageContents(o, a, e, t);
        throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string. Header was: " + o);
    }, osc.writePacket = function(r, e) {
        if (osc.isValidMessage(r)) return osc.writeMessage(r, e);
        if (osc.isValidBundle(r)) return osc.writeBundle(r, e);
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle. Packet was: " + JSON.stringify(r, null, 2));
    }, osc.argumentTypes = {
        i: {
            reader: "readInt32",
            writer: "writeInt32"
        },
        h: {
            reader: "readInt64",
            writer: "writeInt64"
        },
        f: {
            reader: "readFloat32",
            writer: "writeFloat32"
        },
        s: {
            reader: "readString",
            writer: "writeString"
        },
        S: {
            reader: "readString",
            writer: "writeString"
        },
        b: {
            reader: "readBlob",
            writer: "writeBlob"
        },
        t: {
            reader: "readTimeTag",
            writer: "writeTimeTag"
        },
        T: {
            reader: "readTrue"
        },
        F: {
            reader: "readFalse"
        },
        N: {
            reader: "readNull"
        },
        I: {
            reader: "readImpulse"
        },
        d: {
            reader: "readFloat64",
            writer: "writeFloat64"
        },
        c: {
            reader: "readChar32",
            writer: "writeChar32"
        },
        r: {
            reader: "readColor",
            writer: "writeColor"
        },
        m: {
            reader: "readMIDIBytes",
            writer: "writeMIDIBytes"
        }
    }, osc.inferTypeForArgument = function(r) {
        switch (typeof r) {
          case "boolean":
            return r ? "T" : "F";

          case "string":
            return "s";

          case "number":
            return "f";

          case "undefined":
            return "N";

          case "object":
            if (null === r) return "N";
            if (r instanceof Uint8Array || r instanceof ArrayBuffer) return "b";
            if ("number" == typeof r.high && "number" == typeof r.low) return "h";
        }
        throw new Error("Can't infer OSC argument type for value: " + JSON.stringify(r, null, 2));
    }, osc.annotateArguments = function(r) {
        for (var e = [], t = 0; t < r.length; t++) {
            var n, a = r[t];
            if ("object" == typeof a && a.type && void 0 !== a.value) n = a; else if (osc.isArray(a)) n = osc.annotateArguments(a); else {
                n = {
                    type: osc.inferTypeForArgument(a),
                    value: a
                };
            }
            e.push(n);
        }
        return e;
    }, osc.isCommonJS && (module.exports = osc);
}();